#!/usr/bin/env node
// Agent v2: modular tasks, YAML cop, auto-rebase push, diagnostics, run report.
import { execSync } from "node:child_process";
import fs from "node:fs";
import path from "node:path";
import fg from "fast-glob";
import * as YAML from "yaml";

const argv = process.argv.slice(2);
const flags = new Set(argv);
const get = (k, d="") => { const i = argv.indexOf(k); return i>=0 && argv[i+1] ? argv[i+1] : d; };

const APPLY  = flags.has("--apply");
const FORCE  = flags.has("--force");                  // uses --force-with-lease
const NOCHK  = flags.has("--no-check");
const FIXTAB = flags.has("--fix");
const PUSH   = flags.has("--push") || APPLY;
const COMMIT = get("--commit", "chore(agent): automated push");
const REMOTE = get("--remote", process.env.AGENT_REMOTE || "origin");
let   BRANCH = get("--branch", process.env.AGENT_BRANCH || "");

const tasksFromArgs = argv.flatMap((a,i)=> a==="--task" ? [argv[i+1]] : []).filter(Boolean);
const reportDir = "agent_reports";
fs.mkdirSync(reportDir, { recursive: true });

function sh(cmd){ return execSync(cmd,{stdio:["ignore","pipe","pipe"],encoding:"utf8"}).trim(); }
function say(cmd){ console.log("›", cmd); return sh(cmd); }
function now(){ return new Date().toISOString().replace(/[:.]/g,"-"); }

function ensureGit(){
  try { sh("git rev-parse --is-inside-work-tree"); }
  catch { console.error("Not a git repo. Run `git init && git remote add origin <url>`."); process.exit(1); }
}
function currBranch(){ try{ const b=sh("git rev-parse --abbrev-ref HEAD"); return b==="HEAD"?"":b; } catch { return ""; } }
function hasChanges(){ try{ sh("git update-index -q --refresh"); } catch {} return sh("git status --porcelain").length>0; }

const isWorkflow = p => p.replace(/\\/g,"/").startsWith(".github/workflows/");
async function listYaml(){ return fg(["**/*.yml","**/*.yaml","!node_modules/**","!.git/**"],{dot:true}); }
const fixTabs = s => s.replace(/\t/g,"  ");

function validateWorkflow(doc){
  const errs=[]; const root=doc.toJS({maxAliasCount:100});
  const t=v=>Object.prototype.toString.call(v).slice(8,-1);
  if(!root || t(root)!=="Object"){ errs.push("Top-level YAML must be an object."); return errs; }
  if(!("on" in root))   errs.push('Missing top-level "on".');
  if(!("jobs" in root)) errs.push('Missing top-level "jobs".');
  const jobs=root.jobs;
  if(jobs && t(jobs)==="Object"){
    for(const [name,job] of Object.entries(jobs)){
      if(t(job)!=="Object"){ errs.push(`jobs.${name} must be an object.`); continue; }
      if(!("runs-on" in job)) errs.push(`jobs.${name} missing "runs-on".`);
      if(!("steps" in job))   errs.push(`jobs.${name} missing "steps".`);
      const steps=job.steps;
      if(Array.isArray(steps)){
        steps.forEach((st,i)=>{
          if(t(st)!=="Object") errs.push(`jobs.${name}.steps[${i}] must be an object.`);
          else if(!("run" in st) && !("uses" in st))
            errs.push(`jobs.${name}.steps[${i}] needs "run" or "uses".`);
        });
      }
    }
  }
  return errs;
}

async function checkYaml({fixTabsFirst=false}={}){
  const files=await listYaml(); const problems=[];
  for(const file of files){
    let src=fs.readFileSync(file,"utf8");
    if(fixTabsFirst && /\t/.test(src)){
      src=fixTabs(src); fs.writeFileSync(file,src,"utf8");
      console.log(`fixed tabs → spaces: ${file}`);
    }
    const doc = YAML.parseDocument(src, { prettyErrors:true });
    if(doc.errors?.length){
      for(const e of doc.errors){
        problems.push({file,msg:e.message,line:e.linePos?.[0]?.line,col:e.linePos?.[0]?.col});
      }
    } else if(isWorkflow(file)){
      for(const msg of validateWorkflow(doc)) problems.push({file,msg});
    }
  }
  return { ok: problems.length===0, problems, count: files.length };
}

function pushWithRetry(){
  if(!BRANCH) BRANCH = currBranch() || "main";
  try {
    try { sh(`git rev-parse --abbrev-ref --symbolic-full-name ${BRANCH}@{u}`); }
    catch { say(`git push -u ${REMOTE} ${BRANCH}`); console.log("✓ Push complete."); return; }
    const cmd = FORCE ? `git push --force-with-lease ${REMOTE} ${BRANCH}` : `git push ${REMOTE} ${BRANCH}`;
    say(cmd);
  } catch {
    console.log("Push rejected (non-fast-forward). Rebasing onto remote and retrying...");
    try {
      say(`git fetch ${REMOTE} ${BRANCH}`);
      say(`git pull --rebase ${REMOTE} ${BRANCH}`);
      const retry = FORCE ? `git push --force-with-lease ${REMOTE} ${BRANCH}` : `git push ${REMOTE} ${BRANCH}`;
      say(retry);
    } catch {
      console.error("Push still failed after rebase. Fix conflicts, then:");
      console.error("  git status");
      console.error("  # edit files, git add -A, git rebase --continue");
      process.exit(2);
    }
  }
  console.log("✓ Push complete.");
}

function commitAndMaybePush(message){
  say("git add -A");
  if(hasChanges()) say(`git commit -m "${message.replace(/"/g,'\\"')}"`);
  else console.log("No changes to commit.");
  if(PUSH) pushWithRetry();
}

function writeReport(obj){
  const json = JSON.stringify(obj,null,2);
  fs.writeFileSync(path.join(reportDir,"latest.json"), json);
  fs.writeFileSync(path.join(reportDir, `report-${now()}.json`), json);
}

/* --------------------------- Task registry --------------------------- */

const tasks = {
  "diagnose": async () => {
    const info = {};
    try { info.branch = currBranch() || "(detached)"; } catch{}
    try { info.remote = sh("git remote -v").split("\n").slice(0,2); } catch{}
    try { info.node = process.version; } catch{}
    try { info.lastCommits = sh("git --no-pager log --oneline -n 3"); } catch{}
    console.log("diagnose:", JSON.stringify(info,null,2));
    return { ok:true, info };
  },

  "yaml-check": async () => {
    if(NOCHK) return { ok:true, skipped:true };
    const res = await checkYaml({ fixTabsFirst: FIXTAB });
    if(!res.ok){
      console.error("\nYAML check failed:");
      for(const p of res.problems){
        const where = p.line ? `:${p.line}${p.col?":"+p.col:""}` : "";
        console.error(`  - ${p.file}${where}  ${p.msg}`);
      }
    }
    return { ok: res.ok, count: res.count, problems: res.problems };
  },

  "write-test-change": async () => {
    const line = `agent ping ${new Date().toISOString()}\n`;
    fs.appendFileSync("AGENT_TEST.txt", line);
    return { ok:true, file:"AGENT_TEST.txt", appended: line.trim() };
  },

  "commit-push": async () => {
    commitAndMaybePush(COMMIT);
    return { ok:true };
  }
};

// Default task pipeline if none specified
const defaultTasks = ["diagnose", "yaml-check", "commit-push"];

/* -------------------------------- Main -------------------------------- */

(async function main(){
  ensureGit();
  const started = new Date().toISOString();
  const plan = tasksFromArgs.length ? tasksFromArgs : defaultTasks;
  const results = [];
  let ok = true;

  for(const name of plan){
    const fn = tasks[name];
    if(!fn){ results.push({ ok:false, task:name, error:"unknown task" }); ok=false; break; }
    try {
      const r = await fn();
      results.push({ task:name, ...r });
      if(!r.ok){ ok=false; break; }
    } catch (e) {
      results.push({ task:name, ok:false, error:String(e?.message||e) });
      ok=false; break;
    }
  }

  const summary = { ok, started_at: started, finished_at: new Date().toISOString(), plan, results };
  writeReport(summary);
  console.log("Agent report:", path.join(reportDir,"latest.json"));
  if(!ok) process.exit(2);
})();
